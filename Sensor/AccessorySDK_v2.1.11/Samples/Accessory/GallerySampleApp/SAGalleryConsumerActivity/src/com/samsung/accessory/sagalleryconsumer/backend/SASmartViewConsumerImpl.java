/*     * Copyright (c) 2014 Samsung Electronics Co., Ltd.    * All rights reserved.    *    * Redistribution and use in source and binary forms, with or without    * modification, are permitted provided that the following conditions are    * met:    *    *     * Redistributions of source code must retain the above copyright    *        notice, this list of conditions and the following disclaimer.   *     * Redistributions in binary form must reproduce the above   *       copyright notice, this list of conditions and the following disclaimer   *       in the documentation and/or other materials provided with the   *       distribution.   *     * Neither the name of Samsung Electronics Co., Ltd. nor the names of its   *       contributors may be used to endorse or promote products derived from   *       this software without specific prior written permission.   *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package com.samsung.accessory.sagalleryconsumer.backend;import java.io.IOException;import java.util.ArrayList;import java.util.List;import org.json.JSONException;import org.json.JSONObject;import android.content.Intent;import android.os.Binder;import android.os.IBinder;import android.os.Messenger;import android.util.Log;import android.widget.Toast;import com.samsung.accessory.sagalleryconsumer.R;import com.samsung.accessory.sagalleryconsumer.datamodel.ImageFetchModelImpl.ImgReqMsg;import com.samsung.accessory.sagalleryconsumer.datamodel.ImageFetchModelImpl.ImgRespMsg;import com.samsung.accessory.sagalleryconsumer.datamodel.ImageFetchModelImpl.TBListReqMsg;import com.samsung.accessory.sagalleryconsumer.datamodel.ImageFetchModelImpl.TBListRespMsg;import com.samsung.accessory.sagalleryconsumer.datamodel.ImageFetchModelImpl.TBModelJson;import com.samsung.accessory.sagalleryconsumer.datamodel.ImageStructure;import com.samsung.accessory.sagalleryconsumer.datamodel.Model;import com.samsung.android.sdk.SsdkUnsupportedException;import com.samsung.android.sdk.accessory.SA;import com.samsung.android.sdk.accessory.SAAgent;import com.samsung.android.sdk.accessory.SAAuthenticationToken;import com.samsung.android.sdk.accessory.SAPeerAgent;import com.samsung.android.sdk.accessory.SASocket;public class SASmartViewConsumerImpl extends SAAgent {    public static final String TAG = "SmartViewConsumerService";    ImageListReceiver mImageListReceiverRegistered;    public static final int RESULT_FAILURE = 0; // these enums have to freezed    public static final int RESULT_SUCCESS = 1;    public static final int REASON_OK = 0;    public static final int REASON_BITMAP_ENCODING_FAILURE = 1;    public static final int REASON_IMAGE_ID_INVALID = 2;    public static final int GALLERY_CHANNEL_ID = 104; // XML file provided the    // info    public static final String ACTION_ADD_DEVICE = "android.appcessory.device.ADD_DEVICE";    ArrayList<Messenger> mClients = new ArrayList<Messenger>();    public static final int MSG_REGISTER_CLIENT = 1;    public static final int MSG_UNREGISTER_CLIENT = 2;    public static final int MSG_SET_INT_VALUE = 3;    public static final int MSG_SET_STRING_VALUE_CHANNEL1 = 4;    public static final int MSG_SET_STRING_VALUE_CHANNEL2 = 5;    public static final int MSG_CONNECTION_CLOSE = 8;    public static final int MSG_SHOW_PROGRESS = 9;    public static final int MSG_START_SMARTVIEW = 10;    public static final int MSG_STOP_SMARTVIEW = 11;    public static final int MSG_SHOW_NOTIFICATION = 12;    public static final String APPCESSORY_EXTRA_PEER_AGENT = "com.appcessory.peer.agent";    public static final String APPCESSORY_ACTION_PEER_AGENT = "com.appcessory.action.peeragent";    private SASocket mConnectionHandler;    private SA mAccessory;    public SASmartViewConsumerImpl() {        super(TAG, SAGalleryConsumerConnection.class);    }    @Override    public void onCreate() {        super.onCreate();        mAccessory = new SA();        try {            mAccessory.initialize(this);        } catch (SsdkUnsupportedException e) {            if (processUnsupportedException(e) == true) {                return;            }        } catch (Exception e1) {            e1.printStackTrace();            /*             * Your application can not use Samsung Accessory SDK. You             * application should work smoothly without using this SDK, or you             * may want to notify user and close your app gracefully (release             * resources, stop Service threads, close UI thread, etc.)             */            stopSelf();        }    }    private boolean processUnsupportedException(SsdkUnsupportedException e) {        e.printStackTrace();        int errType = e.getType();        if (errType == SsdkUnsupportedException.VENDOR_NOT_SUPPORTED                || errType == SsdkUnsupportedException.DEVICE_NOT_SUPPORTED) {            /*             * Your application can not use Samsung Accessory SDK. You             * application should work smoothly without using this SDK, or you             * may want to notify user and close your app gracefully (release             * resources, stop Service threads, close UI thread, etc.)             */            stopSelf();        } else if (errType == SsdkUnsupportedException.LIBRARY_NOT_INSTALLED) {            Log.e(TAG, "You need to install SAccessory package"                    + " to use this application.");        } else if (errType == SsdkUnsupportedException.LIBRARY_UPDATE_IS_REQUIRED) {            Log.e(TAG, "You need to update SAccessory package"                    + " to use this application.");        } else if (errType == SsdkUnsupportedException.LIBRARY_UPDATE_IS_RECOMMENDED) {            Log.e(TAG,                    "We recommend that you update your"                            + " Samsung Accessory software before using this application.");            return false;        }        return true;    }    @Override    public void onLowMemory() {        closeConnection();        super.onLowMemory();    }    @Override    protected void onFindPeerAgentResponse(SAPeerAgent uRemoteAgent, int result) {        if (result == PEER_AGENT_FOUND) {            if (mImageListReceiverRegistered != null) {                mImageListReceiverRegistered.onPeerFound(uRemoteAgent);            }        }     }    @Override    public void onDestroy() {        super.onDestroy();    }    @Override    protected void onError(SAPeerAgent peerAgent, String error, int errorCode) {    }    @Override    protected void onServiceConnectionResponse(SAPeerAgent peerAgent, SASocket uThisConnection,            int iConnResult) {        if (iConnResult == CONNECTION_SUCCESS) {// SERVICE_CONNECTION_RESULT_OK            this.mConnectionHandler = uThisConnection;            Toast.makeText(getBaseContext(), R.string.ConnectionEstablishedMsg,                    Toast.LENGTH_LONG).show();        }    }    private void onDataAvailableonChannel(long channelId, String data) {        if (data.contains(Model.THUMBNAIL_LIST_RESP)) {            handleThumbnails(data);        } else if (data.contains(Model.DOWNSCALE_IMG_RESP)) {            handleDownscaledImage(data);        }    }    private void handleDownscaledImage(String resp) {        ImageStructure image;        JSONObject obj = null;        try {            obj = new JSONObject(resp);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final ImgRespMsg uResponse = new ImgRespMsg();        try {            uResponse.fromJSON(obj);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        if (uResponse.getResult().equalsIgnoreCase("success")) {// success case            // decode and            // update UI            final TBModelJson img = uResponse.getDownscaledImg();            image = new ImageStructure(String.valueOf(img.getId()),                    img.getData(), String.valueOf(img.getSize()),                    img.getName(), String.valueOf(img.getWidth()),                    String.valueOf(img.getHeight()));            mImageListReceiverRegistered.onImageReceived(image);        }    }    private void handleThumbnails(String resp) {        final List<ImageStructure> uNotificationList = new ArrayList<ImageStructure>();        JSONObject obj = null;        try {            obj = new JSONObject(resp);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final TBListRespMsg uResponse = new TBListRespMsg();        try {            uResponse.fromJSON(obj);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        if (uResponse.getResult().equalsIgnoreCase("success")) {            final List<TBModelJson> list = uResponse.getmsgTBList();            for (final TBModelJson cur : list) {                if (cur != null) {                    final ImageStructure ds = new ImageStructure(                            String.valueOf(cur.getId()), cur.getData(),                            String.valueOf(cur.getSize()), cur.getName(),                            String.valueOf(cur.getWidth()), String.valueOf(cur                                    .getHeight()));                    uNotificationList.add(ds);                }            }        }        mImageListReceiverRegistered.onThumbnailsReceived(uNotificationList); // to    }    public interface ImageListReceiver {        void onThumbnailsReceived(List<ImageStructure> uList);        void onImageReceived(ImageStructure image);        void onPeerFound(SAPeerAgent uRemoteAgent);        void onServiceConnectionLost(int errorcode);    };    public boolean registerImageReciever(ImageListReceiver uImageReceiver) {        mImageListReceiverRegistered = uImageReceiver;        return true;    }    public boolean closeConnection() {        if (mConnectionHandler != null) {            mConnectionHandler.close();            mConnectionHandler = null;        }        return true;    }    public boolean establishConnection(SAPeerAgent peerAgent) {        if (peerAgent != null) {            requestServiceConnection(peerAgent);            return true;        }        return false;    }    public void findPeers() {        findPeerAgents();    }    public boolean requestImage(int index) {        // width and height logic to be developed by consumer , current support        // max 320x240.        final ImgReqMsg uRequest = new ImgReqMsg((long) index, 320, 240);        String uJsonStringToSend = "";        try {            uJsonStringToSend = uRequest.toJSON().toString();        } catch (final JSONException e) {            e.printStackTrace();            return false;        }        if (mConnectionHandler != null) {            try {                mConnectionHandler.send(GALLERY_CHANNEL_ID,                        uJsonStringToSend.getBytes());            } catch (final IOException e) {                e.printStackTrace();            }        }        return true;    }    public boolean requestThumbNail(int countRequested) {        final TBListReqMsg uRequest = new TBListReqMsg((long) countRequested);        String uJsonStringToSend = "";        try {            uJsonStringToSend = uRequest.toJSON().toString();        } catch (final JSONException e) {            e.printStackTrace();            return false;        }        if (mConnectionHandler != null) {            try {                mConnectionHandler.send(GALLERY_CHANNEL_ID,                        uJsonStringToSend.getBytes());            } catch (final IOException e) {                e.printStackTrace();            }        }        return true;    }    private final IBinder mBinder = new LocalBinder();    public class LocalBinder extends Binder {        public SASmartViewConsumerImpl getService() {            return SASmartViewConsumerImpl.this;        }    }    @Override    public IBinder onBind(Intent intent) {        return mBinder;    }    // service connection helper inner class    public class SAGalleryConsumerConnection extends SASocket {        public SAGalleryConsumerConnection() {            super(SAGalleryConsumerConnection.class.getName());        }        @Override        public void onReceive(int channelId, byte[] data) {            final String strToUpdateUI = new String(data);            onDataAvailableonChannel(channelId, strToUpdateUI);        }        @Override        public void onError(int channelId, String errorString, int error) {        }        @Override        public void onServiceConnectionLost(int errorCode) {            mConnectionHandler = null;            mImageListReceiverRegistered.onServiceConnectionLost(errorCode);        }    }    @Override    protected void onPeerAgentUpdated(SAPeerAgent peerAgent, int result) {        if (result == PEER_AGENT_AVAILABLE) {            authenticatePeerAgent(peerAgent);        }    }    @Override    protected void onAuthenticationResponse(SAPeerAgent peerAgent,            SAAuthenticationToken authToken, int code) {        if (code == SAAgent.AUTHENTICATION_SUCCESS                && authToken.getAuthenticationType() == SAAuthenticationToken.AUTHENTICATION_TYPE_CERTIFICATE_X509) {            requestServiceConnection(peerAgent);        }    }}
