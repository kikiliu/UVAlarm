/*     * Copyright (c) 2014 Samsung Electronics Co., Ltd.    * All rights reserved.    *    * Redistribution and use in source and binary forms, with or without    * modification, are permitted provided that the following conditions are    * met:    *    *     * Redistributions of source code must retain the above copyright    *        notice, this list of conditions and the following disclaimer.   *     * Redistributions in binary form must reproduce the above   *       copyright notice, this list of conditions and the following disclaimer   *       in the documentation and/or other materials provided with the   *       distribution.   *     * Neither the name of Samsung Electronics Co., Ltd. nor the names of its   *       contributors may be used to endorse or promote products derived from   *       this software without specific prior written permission.   *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */package com.samsung.accessory.sagalleryprovider.backend;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import org.json.JSONException;import org.json.JSONObject;import android.content.Intent;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Binder;import android.os.IBinder;import android.provider.MediaStore;import android.util.Base64;import android.util.Log;import android.widget.Toast;import com.samsung.accessory.sagalleryprovider.R;import com.samsung.accessory.sagalleryprovider.datamodel.ImageFetchModelImpl.ImgReqMsg;import com.samsung.accessory.sagalleryprovider.datamodel.ImageFetchModelImpl.ImgRespMsg;import com.samsung.accessory.sagalleryprovider.datamodel.ImageFetchModelImpl.TBListReqMsg;import com.samsung.accessory.sagalleryprovider.datamodel.ImageFetchModelImpl.TBListRespMsg;import com.samsung.accessory.sagalleryprovider.datamodel.ImageFetchModelImpl.TBModelJson;import com.samsung.accessory.sagalleryprovider.datamodel.Model;import com.samsung.android.sdk.SsdkUnsupportedException;import com.samsung.android.sdk.accessory.SAAgent;import com.samsung.android.sdk.accessory.SAPeerAgent;import com.samsung.android.sdk.accessory.SASocket;import com.samsung.android.sdk.accessory.SA;public class SASmartViewProviderImpl extends SAAgent {    public static final String TAG = "SmartViewProviderService";    public static final int INITIAL_IMAGE_INDEX = -1;    public static final int REASON_OK = 0;    public static final int REASON_BITMAP_ENCODING_FAILURE = 1;    public static final int REASON_IMAGE_ID_INVALID = 2;    public static final int REASON_EOF_IMAGE = 3;    public static final int REASON_DATABASE_ERROR = 4;    private SA mAccessory;    String[] mProjection = { MediaStore.Images.Media._ID,            MediaStore.Images.Media.DATA, MediaStore.Images.Media.SIZE,            MediaStore.Images.Media.DISPLAY_NAME,            MediaStore.Images.Media.WIDTH, MediaStore.Images.Media.HEIGHT };    HashMap<Integer, SAGalleryProviderConnection> mConnectionsMap = null;    // XML file provided the info    private static final int GALLERY_CHANNEL_ID = 104;    List<TBModelJson> mTb = new ArrayList<TBModelJson>();    String mImgData = "";    public static final String ACTION_ADD_DEVICE = "android.appcessory.device.ADD_DEVICE";    private String mResult = "failure";    private int mReason = REASON_IMAGE_ID_INVALID;    private final IBinder mBinder = new LocalBinder();    public class LocalBinder extends Binder {        public SASmartViewProviderImpl getService() {            return SASmartViewProviderImpl.this;        }    }    @Override    public IBinder onBind(Intent intent) {        return mBinder;    }    @Override    public void onCreate() {        super.onCreate();        mAccessory = new SA();        try {            mAccessory.initialize(this);        } catch (SsdkUnsupportedException e) {            if (processUnsupportedException(e) == true) {                return;            }        } catch (Exception e1) {            e1.printStackTrace();            /*             * Your application can not use Samsung Accessory SDK. You             * application should work smoothly without using this SDK, or you             * may want to notify user and close your app gracefully (release             * resources, stop Service threads, close UI thread, etc.)             */            stopSelf();        }    }    private boolean processUnsupportedException(SsdkUnsupportedException e) {        e.printStackTrace();        int errType = e.getType();        if (errType == SsdkUnsupportedException.VENDOR_NOT_SUPPORTED                || errType == SsdkUnsupportedException.DEVICE_NOT_SUPPORTED) {            /*             * Your application can not use Samsung Accessory SDK. You             * application should work smoothly without using this SDK, or you             * may want to notify user and close your app gracefully (release             * resources, stop Service threads, close UI thread, etc.)             */            stopSelf();        } else if (errType == SsdkUnsupportedException.LIBRARY_NOT_INSTALLED) {            Log.e(TAG, "You need to install SAccessory package"                    + " to use this application.");        } else if (errType == SsdkUnsupportedException.LIBRARY_UPDATE_IS_REQUIRED) {            Log.e(TAG, "You need to update SAccessory package"                    + " to use this application.");        } else if (errType == SsdkUnsupportedException.LIBRARY_UPDATE_IS_RECOMMENDED) {            Log.e(TAG,                    "We recommend that you update your"                            + " Samsung Accessory software before using this application.");            return false;        }        return true;    }    @Override    public void onLowMemory() {        closeConnection();        super.onLowMemory();    }    @Override    public void onDestroy() {        super.onDestroy();    }    public SASmartViewProviderImpl() {        super(TAG, SAGalleryProviderConnection.class);    }    public boolean closeConnection() {        if (mConnectionsMap != null) {            final List<Integer> listConnections = new ArrayList<Integer>(                    mConnectionsMap.keySet());            for (final Integer s : listConnections) {                mConnectionsMap.get(s).close();                mConnectionsMap.remove(s);            }        }        return true;    }    @Override    protected void onServiceConnectionResponse(SAPeerAgent peerAgent, SASocket uThisConnection,            int result) {        if (result == CONNECTION_SUCCESS) {            if (uThisConnection != null) {                final SAGalleryProviderConnection myConnection = (SAGalleryProviderConnection) uThisConnection;                if (mConnectionsMap == null) {                    mConnectionsMap = new HashMap<Integer, SAGalleryProviderConnection>();                }                myConnection.mConnectionId = (int) (System.currentTimeMillis() & 255);                mConnectionsMap.put(myConnection.mConnectionId, myConnection);                Toast.makeText(getBaseContext(),                        R.string.ConnectionEstablishedMsg, Toast.LENGTH_LONG)                        .show();            }        }    }    private void onDataAvailableonChannel(String connectedPeerId,            long channelId, String data) {        if (data.contains(Model.THUMBNAIL_LIST_RQST)) {            sendThumbnails(connectedPeerId, data);        } else if (data.contains(Model.DOWNSCALE_IMG_RQST)) {            sendDownscaledImage(connectedPeerId, data);        }    }    private void publishMediaStoreInfo(Cursor imageCursor) {        for (int j = 0; j < imageCursor.getCount(); j++) {            imageCursor.moveToNext();        }        imageCursor.moveToFirst();    }    private boolean pullThumbnails(Cursor imageCursor) {        String data = "";        final long img_id = imageCursor.getLong(imageCursor                .getColumnIndex(MediaStore.Images.Media._ID));        final Bitmap bm = MediaStore.Images.Thumbnails.getThumbnail(                getApplicationContext().getContentResolver(), img_id,                MediaStore.Images.Thumbnails.MICRO_KIND, null);        if (bm == null) {            return false;        }        final ByteArrayOutputStream stream = new ByteArrayOutputStream();        bm.compress(Bitmap.CompressFormat.JPEG, 80, stream);        data = Base64.encodeToString(stream.toByteArray(), Base64.NO_WRAP);        try {            stream.close();        } catch (final IOException e) {            e.printStackTrace();        }        final long img_size = imageCursor.getLong(imageCursor                .getColumnIndex(MediaStore.Images.Media.SIZE));        final String name = imageCursor.getString(imageCursor                .getColumnIndex(MediaStore.Images.Media.DISPLAY_NAME));        final int width = imageCursor.getInt(imageCursor                .getColumnIndex(MediaStore.Images.Media.WIDTH));        final int height = imageCursor.getInt(imageCursor                .getColumnIndex(MediaStore.Images.Media.HEIGHT));        final TBModelJson msg = new TBModelJson(img_id, name, data, img_size,                width, height);        mTb.add(msg);        return true;    }    private void sendThumbnails(String connectedPeerId, String request) {        boolean ret = true;        mResult = "failure";        mReason = REASON_IMAGE_ID_INVALID;        int count = 0;        if (!mTb.isEmpty()) {            mTb.clear();        }        JSONObject obj = null;        try {            obj = new JSONObject(request);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final TBListReqMsg uRequest = new TBListReqMsg();        try {            uRequest.fromJSON(obj);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final long id = uRequest.getID();        Cursor imageCursor = getContentResolver().query(                MediaStore.Images.Media.EXTERNAL_CONTENT_URI, mProjection,                null, null, null);        if (imageCursor == null) {            mReason = REASON_DATABASE_ERROR;            sendTbListMsg(connectedPeerId);            return;        }        imageCursor.moveToFirst();        publishMediaStoreInfo(imageCursor);        if (id != INITIAL_IMAGE_INDEX) {            for (int i = 0; i < imageCursor.getCount(); i++) {                if (id == imageCursor.getInt(imageCursor                        .getColumnIndex(MediaStore.Images.Media._ID))) {                    ret = imageCursor.moveToNext();                    break;                }                if (imageCursor.moveToNext() == false) {                    ret = false;                    break;                }            }        }        final int size = imageCursor.getCount();        if ((ret == true) && (size > 0)) {            do {                final boolean status = pullThumbnails(imageCursor);                if (status == true) {                    count++;                }            } while (count < 3 && imageCursor.moveToNext());            mResult = "success";            mReason = REASON_OK;        } // check to ignore in case id is last record in DB        else {            mReason = REASON_EOF_IMAGE;        }        if (!imageCursor.isClosed()) {            imageCursor.close();        }        sendTbListMsg(connectedPeerId);    }    private void sendTbListMsg(String connectedPeerId) {        final TBListRespMsg uRMessage = new TBListRespMsg(mResult, mReason,                mTb.size(), mTb);        String uJsonStringToSend = "";        try {            uJsonStringToSend = uRMessage.toJSON().toString();        } catch (final JSONException e) {            e.printStackTrace();        }        if (mConnectionsMap != null) {            final SAGalleryProviderConnection uHandler = mConnectionsMap                    .get(Integer.parseInt(connectedPeerId));            if(uHandler !=null){            	try {            		uHandler.send(GALLERY_CHANNEL_ID, uJsonStringToSend.getBytes());            	} catch (final IOException e) {                    e.printStackTrace();                }            }        }    }    private void pullDownscaledImg(String path, int width, int height) {        final BitmapFactory.Options opt = new BitmapFactory.Options();        opt.inScaled = false;        opt.inSampleSize = 4; // logic based on original and requested size.        final Bitmap scaledbitmap = Bitmap.createScaledBitmap(                BitmapFactory.decodeFile(path, opt), width, height, false);        if (scaledbitmap != null) {            final ByteArrayOutputStream stream = new ByteArrayOutputStream();            scaledbitmap.compress(Bitmap.CompressFormat.JPEG, 80, stream);            mImgData = Base64.encodeToString(stream.toByteArray(),                    Base64.NO_WRAP);            try {                stream.close();            } catch (final IOException e) {                e.printStackTrace();            }        }        mResult = "success"; // success        mReason = REASON_OK; // ok    }    private void sendDownscaledImage(String connectedPeerId, String request) {        // put a upper cap like say 320x240 for image        mImgData = "";        mResult = "failure";        mReason = REASON_IMAGE_ID_INVALID;        int orgWidth = 0, orgHeight = 0;        long orgSize = 0;        String orgName = "";        JSONObject obj = null;        try {            obj = new JSONObject(request);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final ImgReqMsg uMessage = new ImgReqMsg();        try {            uMessage.fromJSON(obj);        } catch (final JSONException e) {            e.printStackTrace();            return;        }        final long id = uMessage.getID();        final int width = uMessage.getWidth();        final int height = uMessage.getHeight();        Cursor imageCursor = getContentResolver().query(                MediaStore.Images.Media.EXTERNAL_CONTENT_URI, mProjection,                MediaStore.Images.Media._ID + " = " + id, null, null);        if (imageCursor != null && imageCursor.moveToFirst()) {            final String path = imageCursor.getString(imageCursor                    .getColumnIndex(MediaStore.Images.Media.DATA));            orgWidth = imageCursor.getInt(imageCursor                    .getColumnIndex(MediaStore.Images.Media.WIDTH));            orgHeight = imageCursor.getInt(imageCursor                    .getColumnIndex(MediaStore.Images.Media.HEIGHT));            orgName = imageCursor.getString(imageCursor                    .getColumnIndex(MediaStore.Images.Media.DISPLAY_NAME));            orgSize = imageCursor.getLong(imageCursor                    .getColumnIndex(MediaStore.Images.Media.SIZE));            final int ed = imageCursor.getInt(imageCursor                    .getColumnIndex(MediaStore.Images.Media._ID));            if (!imageCursor.isClosed()) {                imageCursor.close();            }            pullDownscaledImg(path, width, height);        } else {            mResult = "failure";// failure            mReason = REASON_IMAGE_ID_INVALID; // invalid image ID.        }        sendImgRsp(connectedPeerId, id, orgName, orgSize, orgWidth, orgHeight);    }    private void sendImgRsp(String connectedPeerId, long id, String orgName,            long orgSize, int orgWidth, int orgHeight) {        final TBModelJson msg = new TBModelJson(id, orgName, mImgData, orgSize,                orgWidth, orgHeight);        final ImgRespMsg uresponse = new ImgRespMsg(mResult, mReason, msg);        String uJsonStringToSend = "";        try {            uJsonStringToSend = uresponse.toJSON().toString();        } catch (final JSONException e) {            e.printStackTrace();        }        if (mConnectionsMap != null) {            final SAGalleryProviderConnection uHandler = mConnectionsMap                    .get(Integer.parseInt(connectedPeerId));            if(uHandler != null){                try {                    uHandler.send(GALLERY_CHANNEL_ID, uJsonStringToSend.getBytes());                } catch (final IOException e) {                    e.printStackTrace();                }            }        }    }    @Override    protected void onFindPeerAgentResponse(SAPeerAgent peerAgent, int result) {    }    @Override    protected void onError(SAPeerAgent peerAgent, String error, int errorCode) {    }    public class SAGalleryProviderConnection extends SASocket {        public static final String TAG = "SAGalleryProviderConnection";        private int mConnectionId;        public SAGalleryProviderConnection() {            super(SAGalleryProviderConnection.class.getName());        }        @Override        public void onReceive(int channelId, byte[] data) {            final String strToUpdateUI = new String(data);            onDataAvailableonChannel(String.valueOf(mConnectionId), channelId, // getRemotePeerId()                    strToUpdateUI);        }        @Override        public void onError(int channelId, String errorString, int error) {        }        @Override        public void onServiceConnectionLost(int errorCode) {            if (mConnectionsMap != null) {                mConnectionsMap.remove(mConnectionId);            }        }    }    @Override    protected void onPeerAgentUpdated(SAPeerAgent peerAgent, int result) {    }}